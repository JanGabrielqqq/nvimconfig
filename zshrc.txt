# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)

source $ZSH/oh-my-zsh.sh

# User configuration

# Set user variable for Windows paths
user="Work"

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
alias zshconf="nvim ~/.zshrc"
alias nvimconf="cd ~/.config/nvim && nvim"
alias tmconf="nvim ~/.config/tmux/tmux.conf"
# alias ohmyzsh="mate ~/.oh-my-zsh"
alias cls="clear"
alias cc="clear"

tn() {
  ~/tnsesh.sh "$1"
}

t() {
    # local dir
    # dir=$(fdfind . 'Projects' --type d | fzf)
    #
    # if [[ -n "$dir" ]]; then
      ~/tsesh.sh "$1"
    # else
    #     echo "No directory selected."
    # fi
}

ddd() {
    local dir
    dir=$(fdfind --type d . ~/Projects | fzf)
    if [[ -n "$dir" ]]; then
        cd "$dir" || echo "Failed to cd to $dir"
    else
        echo "No directory selected."
    fi
}

confpush() {
    local nvim_config_dir="$HOME/.config/nvim"
    
    # Create nvim config directory if it doesn't exist
    mkdir -p "$nvim_config_dir"
    
    # Copy and rename files
    cp "$HOME/.zshrc" "$nvim_config_dir/zshrc.txt"
    cp "$HOME/.tmux.conf" "$nvim_config_dir/.tmux.conf.txt"
    cp "$HOME/tnsesh.sh" "$nvim_config_dir/tnsesh.sh.txt"
    cp "$HOME/tsesh.sh" "$nvim_config_dir/tsesh.sh.txt"
    
    # Delete the old file
    rm -f "$nvim_config_dir/tsesh.sh.text"
    
    echo "Files synced to nvim config directory"
}

confpull() {
    local nvim_config_dir="$HOME/.config/nvim"
    local backup_dir="$HOME/.config_backups"
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    
    # Create backup directory if it doesn't exist
    mkdir -p "$backup_dir"
    
    # Create backups before overwriting
    echo "Creating backups..."
    if [[ -f "$HOME/.zshrc" ]]; then
        cp "$HOME/.zshrc" "$backup_dir/.zshrc.backup.$timestamp"
        echo "Backed up .zshrc to $backup_dir/.zshrc.backup.$timestamp"
    fi
    if [[ -f "$HOME/.tmux.conf" ]]; then
        cp "$HOME/.tmux.conf" "$backup_dir/.tmux.conf.backup.$timestamp"
        echo "Backed up .tmux.conf to $backup_dir/.tmux.conf.backup.$timestamp"
    fi
    if [[ -f "$HOME/tnsesh.sh" ]]; then
        cp "$HOME/tnsesh.sh" "$backup_dir/tnsesh.sh.backup.$timestamp"
        echo "Backed up tnsesh.sh to $backup_dir/tnsesh.sh.backup.$timestamp"
    fi
    if [[ -f "$HOME/tsesh.sh" ]]; then
        cp "$HOME/tsesh.sh" "$backup_dir/tsesh.sh.backup.$timestamp"
        echo "Backed up tsesh.sh to $backup_dir/tsesh.sh.backup.$timestamp"
    fi
    
    # Copy and rename files back to home directory
    cp "$nvim_config_dir/zshrc.txt" "$HOME/.zshrc"
    cp "$nvim_config_dir/.tmux.conf.txt" "$HOME/.tmux.conf"
    cp "$nvim_config_dir/tnsesh.sh.txt" "$HOME/tnsesh.sh"
    cp "$nvim_config_dir/tsesh.sh.txt" "$HOME/tsesh.sh"
    
    echo "Files restored from nvim config directory"
    echo "Backups saved to $backup_dir with timestamp $timestamp"
    
    # Show diff of changes
    echo -e "\n=== CHANGES SUMMARY ==="
    local files_to_diff=(
        ".zshrc:$backup_dir/.zshrc.backup.$timestamp"
        ".tmux.conf:$backup_dir/.tmux.conf.backup.$timestamp"
        "tnsesh.sh:$backup_dir/tnsesh.sh.backup.$timestamp"
        "tsesh.sh:$backup_dir/tsesh.sh.backup.$timestamp"
    )
    
    for file_pair in "${files_to_diff[@]}"; do
        local current_file="${file_pair%%:*}"
        local backup_file="${file_pair##*:}"
        local full_current_path="$HOME/$current_file"
        
        if [[ -f "$backup_file" && -f "$full_current_path" ]]; then
            echo -e "\n--- Changes in $current_file ---"
            if diff -q "$backup_file" "$full_current_path" >/dev/null 2>&1; then
                echo "No changes detected"
            else
                diff -u "$backup_file" "$full_current_path" | head -20
                local line_count=$(diff -u "$backup_file" "$full_current_path" | wc -l)
                if [[ $line_count -gt 20 ]]; then
                    echo "... (showing first 20 lines of diff, $line_count total lines)"
                fi
            fi
        fi
    done
    echo "========================"
}

confreset() {
    local backup_dir="$HOME/.config_backups"
    
    # Check if backup directory exists
    if [[ ! -d "$backup_dir" ]]; then
        echo "No backup directory found at $backup_dir"
        return 1
    fi
    
    # List available backups
    echo "Available backup timestamps:"
    ls "$backup_dir" | grep -E '\.(backup\.[0-9]{8}_[0-9]{6})$' | sed 's/.*\.backup\.\([0-9_]*\)$/\1/' | sort -u | nl
    
    if [[ $(ls "$backup_dir"/*.backup.* 2>/dev/null | wc -l) -eq 0 ]]; then
        echo "No backups found in $backup_dir"
        return 1
    fi
    
    # Get user selection
    read -r "timestamp?Enter timestamp to restore (format: YYYYMMDD_HHMMSS): "
    
    if [[ ! "$timestamp" =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
        echo "Invalid timestamp format. Use YYYYMMDD_HHMMSS"
        return 1
    fi
    
    # Check which backup files exist for this timestamp
    local files_to_restore=(
        ".zshrc:$backup_dir/.zshrc.backup.$timestamp"
        ".tmux.conf:$backup_dir/.tmux.conf.backup.$timestamp"
        "tnsesh.sh:$backup_dir/tnsesh.sh.backup.$timestamp"
        "tsesh.sh:$backup_dir/tsesh.sh.backup.$timestamp"
    )
    
    echo "Restoring files from backup timestamp: $timestamp"
    local restored_count=0
    
    for file_pair in "${files_to_restore[@]}"; do
        local current_file="${file_pair%%:*}"
        local backup_file="${file_pair##*:}"
        local full_current_path="$HOME/$current_file"
        
        if [[ -f "$backup_file" ]]; then
            cp "$backup_file" "$full_current_path"
            echo "✓ Restored $current_file"
            ((restored_count++))
        else
            echo "✗ Backup not found: $backup_file"
        fi
    done
    
    if [[ $restored_count -gt 0 ]]; then
        echo "Successfully restored $restored_count file(s) from backup $timestamp"
        echo "Note: You may need to reload your shell or run 'source ~/.zshrc' for changes to take effect"
    else
        echo "No files were restored"
        return 1
    fi
}

# Windows file copy utility functions
wincp() {
    local source_type=""
    local source_path=""
    local selected_file=""
    local dest_dir=""
    
    # Show options for source directory
    echo "Select source directory:"
    echo "1) Downloads"
    echo "2) Documents"
    read -r "choice?Enter choice (1-2): "
    
    case $choice in
        1)
            source_type="Downloads"
            source_path="/mnt/c/Users/$user/Downloads"
            ;;
        2)
            source_type="Documents"
            source_path="/mnt/c/Users/$user/Documents"
            ;;
        *)
            echo "Invalid choice"
            return 1
            ;;
    esac
    
    # Check if source directory exists
    if [[ ! -d "$source_path" ]]; then
        echo "Source directory $source_path does not exist"
        return 1
    fi
    
    # Select file/folder from source using fzf
    echo "Selecting from $source_type..."
    selected_file=$(find "$source_path" -maxdepth 3 -type f -o -type d | sed "s|$source_path/||" | fzf --height=20 --preview="ls -la '$source_path/{}'")
    
    if [[ -z "$selected_file" ]]; then
        echo "No file selected"
        return 1
    fi
    
    # Select destination folder in ~/Projects using fzf
    echo "Select destination in ~/Projects..."
    dest_dir=$(find ~/Projects -type d | fzf --height=20 --preview="ls -la {}")
    
    if [[ -z "$dest_dir" ]]; then
        echo "No destination selected"
        return 1
    fi
    
    # Copy the file/folder
    local full_source_path="$source_path/$selected_file"
    echo "Copying '$selected_file' to '$dest_dir'"
    
    if [[ -d "$full_source_path" ]]; then
        cp -r "$full_source_path" "$dest_dir/"
    else
        cp "$full_source_path" "$dest_dir/"
    fi
    
    if [[ $? -eq 0 ]]; then
        echo "✓ Successfully copied '$selected_file' to '$dest_dir'"
    else
        echo "✗ Failed to copy file"
        return 1
    fi
}

# Shortcut functions for specific directories
wincpd() {
    local source_path="/mnt/c/Users/$user/Downloads"
    local selected_file=""
    local dest_dir=""
    
    if [[ ! -d "$source_path" ]]; then
        echo "Downloads directory $source_path does not exist"
        return 1
    fi
    
    selected_file=$(find "$source_path" -maxdepth 3 -type f -o -type d | sed "s|$source_path/||" | fzf --height=20 --preview="ls -la '$source_path/{}'")
    
    if [[ -z "$selected_file" ]]; then
        echo "No file selected"
        return 1
    fi
    
    dest_dir=$(find ~/Projects -type d | fzf --height=20 --preview="ls -la {}")
    
    if [[ -z "$dest_dir" ]]; then
        echo "No destination selected"
        return 1
    fi
    
    local full_source_path="$source_path/$selected_file"
    echo "Copying '$selected_file' to '$dest_dir'"
    
    if [[ -d "$full_source_path" ]]; then
        cp -r "$full_source_path" "$dest_dir/"
    else
        cp "$full_source_path" "$dest_dir/"
    fi
    
    if [[ $? -eq 0 ]]; then
        echo "✓ Successfully copied '$selected_file' to '$dest_dir'"
    else
        echo "✗ Failed to copy file"
        return 1
    fi
}

wincpdoc() {
    local source_path="/mnt/c/Users/$user/Documents"
    local selected_file=""
    local dest_dir=""
    
    if [[ ! -d "$source_path" ]]; then
        echo "Documents directory $source_path does not exist"
        return 1
    fi
    
    selected_file=$(find "$source_path" -maxdepth 3 -type f -o -type d | sed "s|$source_path/||" | fzf --height=20 --preview="ls -la '$source_path/{}'")
    
    if [[ -z "$selected_file" ]]; then
        echo "No file selected"
        return 1
    fi
    
    dest_dir=$(find ~/Projects -type d | fzf --height=20 --preview="ls -la {}")
    
    if [[ -z "$dest_dir" ]]; then
        echo "No destination selected"
        return 1
    fi
    
    local full_source_path="$source_path/$selected_file"
    echo "Copying '$selected_file' to '$dest_dir'"
    
    if [[ -d "$full_source_path" ]]; then
        cp -r "$full_source_path" "$dest_dir/"
    else
        cp "$full_source_path" "$dest_dir/"
    fi
    
    if [[ $? -eq 0 ]]; then
        echo "✓ Successfully copied '$selected_file' to '$dest_dir'"
    else
        echo "✗ Failed to copy file"
        return 1
    fi
}

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion


# pnpm
export PNPM_HOME="/home/gab/.local/share/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end
